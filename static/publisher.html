<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Publisher</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Publishing Camera â†’ Server</h1>
    <video id="preview" autoplay playsinline muted></video>

<script>
const log = (...a)=>{ console.log(a) };

(async () => {
  // 1) WebSocket signaling
  const ws = new WebSocket(`wss://${location.host}/api/webrtc/publish`);
  await new Promise((res, rej) => { ws.onopen = res; ws.onerror = rej; });
  log('ws: open');

  // 2) Camera
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { width: { ideal: 1280 }, height: { ideal: 720 } },
    audio: false
  });
  document.getElementById('preview').srcObject = stream;

  // 3) RTCPeerConnection (LAN / same-host: no STUN/TURN)
  const pc = new RTCPeerConnection({ iceServers: [], iceCandidatePoolSize: 1 });

  pc.onicecandidate = (e) => {
    ws.send(JSON.stringify(e.candidate ? {
      type: 'candidate',
      candidate: e.candidate.candidate,
      sdpMid: e.candidate.sdpMid,
      sdpMLineIndex: e.candidate.sdpMLineIndex
    } : { type: 'end_of_candidates' }));
  };

  // 4) Add track
  const [videoTrack] = stream.getVideoTracks();
  const sender = pc.addTrack(videoTrack, stream);

  // 5) Data channel for per-frame tags
  const dc = pc.createDataChannel('ts', { ordered: true });
  dc.onopen  = () => log('datachannel(ts): open');
  dc.onerror = (e) => log('datachannel(ts) error:', e?.message || e);

  // 6) Encoded-frame transform: send {frame_id, pts90k} for every encoded frame
  const mk = sender.createEncodedVideoStreams ?? sender.createEncodedStreams;
  if (typeof mk !== 'function') {
    log('Encoded transform API not available (createEncodedVideoStreams).');
  } else {
    const { readable, writable } = mk.call(sender);
    let frame_id = 0;

    const passthrough = new TransformStream({
      transform(chunk, controller) {
        // Chrome provides chunk.timestamp in MICROseconds.
        const time = chunk.timestamp;  // TODO replace with 

        if (dc.readyState === 'open') {
          dc.send(JSON.stringify({ frame_id, time }));
        }

        frame_id++;
        controller.enqueue(chunk); // forward encoded frame unchanged
      }
    });

    readable.pipeThrough(passthrough).pipeTo(writable);
    log('encoded transform attached');
  }

  // 7) Offer/answer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
  log('offer sent');

  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);
    if (msg.type === 'answer') {
      await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
      log('answer set');
    }
  };

  // Optional: basic state logs
  pc.oniceconnectionstatechange = () => log('ice:', pc.iceConnectionState);
  pc.onconnectionstatechange    = () => log('pc:', pc.connectionState);

  // Cleanup
  window.addEventListener('beforeunload', () => {
    try { pc.close(); } catch {}
    stream.getTracks().forEach(t => t.stop());
    try { ws.close(); } catch {}
  });
})();
</script>
</body>
</html>

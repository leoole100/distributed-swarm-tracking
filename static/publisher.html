<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Publisher</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Publishing Camera → Server</h1>
    <video id="preview" autoplay playsinline muted></video>

<script>
const log = (...a)=>{ console.log(a) };

(async () => {
  // 1) Open WebSocket signaling
  const ws = new WebSocket(`wss://${location.host}/api/webrtc/publish`);
  await new Promise((resolve, reject) => {
    ws.onopen = resolve;
    ws.onerror = reject;
  });
  log('ws open');

  // 2) Get camera
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { width: { ideal: 1280 }, height: { ideal: 720 } },
    audio: false
  });
  document.getElementById('preview').srcObject = stream;

  // 3) Create RTCPeerConnection (no STUN/TURN → host candidates)
  const pc = new RTCPeerConnection({
    iceServers: [],
    iceCandidatePoolSize: 1
  });

  pc.onicegatheringstatechange = () => log('gather:', pc.iceGatheringState);
  pc.oniceconnectionstatechange = () => log('ice:', pc.iceConnectionState);
  pc.onconnectionstatechange    = () => log('pc:', pc.connectionState);

  // 4) Trickle ICE from browser → server
  pc.onicecandidate = (e) => {
    if (e.candidate) {
      ws.send(JSON.stringify({
        type: 'candidate',
        candidate: e.candidate.candidate,
        sdpMid: e.candidate.sdpMid,
        sdpMLineIndex: e.candidate.sdpMLineIndex
      }));
    } else {
      // Signal end-of-candidates when gathering completes
      ws.send(JSON.stringify({ type: 'end_of_candidates' }));
    }
  };

  // 5) Add local tracks
  stream.getTracks().forEach(t => pc.addTrack(t, stream));

  // 6) Create offer and set local
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // 7) Send offer immediately (trickle candidates will follow)
  ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
  log('offer sent');

  // 8) Handle server messages (answer + optional trickle back)
  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);

    if (msg.type === 'answer') {
      await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
      log('answer set');
    } else if (msg.type === 'candidate') {
      await pc.addIceCandidate(msg.candidate);
    }
  };

  // Optional: clean up if WS closes
  ws.onclose = () => {
    log('ws closed');
    try { pc.close(); } catch {}
    stream.getTracks().forEach(t => t.stop());
  };
})();
</script>
</body>
</html>
